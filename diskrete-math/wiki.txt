Поглощающее(существенное) состояние цепи Маркова - состояние с вероятностью перехода в самого себя <tex>p_{ii}=1</tex>.
Составим матрицу <tex>G</tex>, элементы которой <tex>g_{ij}</tex> равны вероятности того, что, выйдя из <tex>i</tex>, попадём в поглощающее состояние <tex>j</tex>.
{{Теорема
|statement=
<tex> G = N \cdot R </tex>
|proof=
Пусть этот переход будет осуществлён за <tex>r</tex> шагов:  <tex>i</tex> &rarr;  <tex>i_{1}</tex> &rarr; <tex>i_{2}</tex> &rarr; ... &rarr; <tex>i_{r-1}</tex> &rarr; j, где все <tex>i, i_{1}, ... i_{r-1}</tex> являются несущественными.
Тогда рассмотрим сумму <tex>\sum\limits_{\forall(i_{1} ... i_{r-1})} {p_{i, i_{1}} \cdot p_{i_{1}, i_{2}} \cdot ... \cdot p_{i_{r-1}, j}} = Q^{r-1} \cdot R</tex>, где <tex>Q</tex> - матрица переходов между несущественными состояниями, <tex>R</tex> - из несущественного в существенное. 
Матрица <tex>G</tex> определяется их суммированием по всем длинам пути из i в j: <tex>G = \sum\limits_{r = 1}^{\infty}{Q^{r-1} \cdot R} = (I + Q + Q^{2} + Q^{3} + ...) \cdot R = NR</tex>, т.к. <tex>(I + Q + Q^2 + ...) \cdot (I - Q) = I - Q + Q - Q^{2} + ... = I</tex>, а фундаментальная матрица марковской цепи <tex>N = (I - Q)^{-1}</tex> }}
=Псевдокод=
Пусть <tex>\mathtt{n}</tex> - количество состояний Марковской цепи, <tex>\mathtt{m}</tex> - количество переходов. Состояния пронумерованы от <tex>0</tex> до <tex>\mathtt{n} - 1</tex>, переходы от <tex>0</tex> до <tex>\mathtt{m} - 1</tex>.  Входные данные хранятся в массиве <tex>\mathtt{input}</tex> где <tex>\mathtt{i}</tex>-ая строка характеризует <tex>\mathtt{i}</tex>-ый переход таким образом: <tex>\mathtt{input[i][2]}</tex> - вероятность перехода из состояния <tex>\mathtt{input[i][0]}</tex> в состояние <tex>\mathtt{input[i][1]}</tex>.
Создадим массив <tex>\mathtt{absorbing}</tex> типа boolean, где <tex>\mathtt{i}</tex>-ое true обозначает что <tex>\mathtt{i}</tex>-ое состояние является поглощающим и наоборот. Обнаружим поглощающие состояния по такому признаку: если состояние поглощающее, то с вероятностью <tex>1</tex> оно переходит само в себя. Также посчитаем количество поглощающих состояний <tex>\mathtt{abs}</tex>.
<code style = "display: inline-block;">
 '''function''' findAbsorbings(input: '''int'''[m][2]):
     '''int''' abs = 0
     '''boolean''' absorbing[m]
     '''for''' i = 0 '''to''' m - 1
        '''if''' input[i][0] == input[i][1] '''and''' input[i][2] == 1
           absorbing[input[i][0]] = ''true''
           abs++
     '''return''' makePair(abs, absorbing)
</code>

Найдем число несущественных состояний <tex>\mathtt{nonabs = n - abs}</tex>. Теперь нужно заполнить матрицы <tex>\mathtt{Q}</tex> (переходов между несущественными состояниями) и <tex>\mathtt{R}</tex> (переходов из несущественных состояний в поглощающие). Для этого создадим сначала массив <tex>\mathtt{position}</tex> где <tex>\mathtt{i}</tex>-ый элемент указывает под каким номером будет находиться <tex>\mathtt{i}</tex>-ое состояние среди существенных если оно существенное или несущественных в обратном случае, и заполним эти массивы.
<code style = "display: inline-block;">
'''procedure''' fullfillQRMatrix(absorbing: '''boolean'''[n], input
     count_q = 0
     count_r = 0
     '''for''' i = 0 '''to''' n - 1
        '''if''' absorbing[i]
               position[i] = count_r
               count_r++
        '''else''' 
               position[i] = count_q
               count_q++
     '''for''' i = 0 '''to''' m - 1
        '''if''' absorbing[input[i][1]]
           '''if''' !absorbing[input[i][0]]
              R[position[input[i][0]]][position[input[i][1]]] = input[i][2]
        '''else'''
           Q[position[input[i][0]]][position[input[i][1]]] = input[i][2]
</code>
Найдем Матрицу <tex>E = I - Q</tex> и создадим единичную матрицу <tex>N</tex>.
<code style = "display: inline-block;">
 '''for''' i = 0 '''to''' nonabs - 1
    N[i][i] = 1
    E[i][i] = 1
    '''for''' j = 0 '''to''' nonabs - 1
       E[i][j] -= Q[i][j]  
</code>
Теперь приведем матрицу <tex>E</tex> к единичной методом Гаусса - Жордана, применяя те же преобразования к матрице <tex>N</tex>.
<code style = "display: inline-block;">
 '''for''' i = 0 '''to''' nonabs - 1
    '''if''' E[i][i] <tex> \neq </tex> 1
       mul = E[i][i]
       '''for''' j = 0 '''to''' nonabs - 1
          E[i][j] /= mul
          N[i][j] /= mul
    '''for''' row = 0 '''to''' nonabs - 1
       '''if''' i <tex> \neq </tex> row
          mul = E[row][i]
          '''for''' j = 0 '''to''' nonabs - 1
             E[row][j] -= mul * E[i][j]
             N[row][j] -= mul * N[i][j]
</code>
В результате <tex>N = E^{-1}</tex>  т.е. <tex>N</tex> - фундаментальная матрица Марковской цепи. Найдем матрицу <tex>G = NR</tex>.
<code style = "display: inline-block;">
 '''for''' i = 0 '''to''' nonabs - 1
    '''for''' j = 0 '''to''' abs - 1
       G[i][j] = 0
       '''for''' k = 0 '''to''' nonabs - 1
          G[i][j] += N[i][k] * R[k][j]
</code>
Выведем ответ: в <tex>i</tex>-ой строке вероятность поглощения в <tex>i</tex>-ом состоянии. Естественно, для несущественного состояния это <tex>0</tex>, в ином случае <tex>p_i=(($$\sum_{k=1}^n G[k][j]$$)+1)/n</tex> где <tex>j</tex> - номер соответствующий <tex>i</tex>-ому состоянию в матрице <tex>G</tex> (т.е. под которым оно располагалось в матрице <tex>R</tex> т.е. значение <tex>position[i]</tex>). Прибавлять 1 нужно т.к. вероятность поглотиться в <tex>i</tex>-ом поглощающем состоянии, оказавшись изначально в нем же равна 1.
<code style = "display: inline-block;">
 '''for''' i = 0 '''to''' n - 1
    prob = 0
    '''if''' absorbing[i]
       '''for''' j = 0 '''to''' nonabs - 1
          prob += G[j][position[i]]
       prob++
       prob /= n
    println(prob)
</code>

=Литература=
* [http://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BF%D1%8C_%28%D0%BC%D0%B0%D1%82%D0%B5%D0%BC.%29 Википедия - Цепи Маркова]
* Кемени Дж., Снелл Дж. "Конечные цепи Маркова".

[[Категория:Дискретная математика и алгоритмы]]

[[Категория: Марковские цепи ]]
